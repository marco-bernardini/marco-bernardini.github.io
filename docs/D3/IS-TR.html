<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Il modello IS-TR – Marco Bernardini</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-0a69ef66e92badd8c5f9ec924b1ec991.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Marco Bernardini</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../macroeconomics.html"> 
<span class="menu-text">Macroeconomics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../data-analysis.html"> 
<span class="menu-text">Data Analysis</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#la-domanda-aggregata" id="toc-la-domanda-aggregata" class="nav-link active" data-scroll-target="#la-domanda-aggregata">La domanda aggregata</a></li>
  <li><a href="#la-curva-is" id="toc-la-curva-is" class="nav-link" data-scroll-target="#la-curva-is">La curva IS</a></li>
  <li><a href="#la-curva-tr" id="toc-la-curva-tr" class="nav-link" data-scroll-target="#la-curva-tr">La curva TR</a></li>
  <li><a href="#il-modello-is-tr" id="toc-il-modello-is-tr" class="nav-link" data-scroll-target="#il-modello-is-tr">Il modello IS-TR</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Il modello IS-TR</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<script src="https://d3js.org/d3.v7.min.js"></script>
<p>Il modello IS-TR viene utilizzato per rappresentare l’equilibrio economico di breve periodo dal punto di vista qualitativo.<br>
L’ipotesi di base, proveniente da Keynes, è che nel breve periodo il livello dei prezzi sia “vischioso” (costante). In periodi di normale attività economica, in assenza di squilibri dal punto di vista geopolitico, si tratta di un’ipotesi ragionevole e supportata dai dati. In questo modello sono presenti due mercati, quello dei beni (e servizi) e quello della moneta.<br>
La seconda ipotesi del modello è che i mercati raggiungano l’equilibrio, e lo raggiungano simultaneamente.<br>
Si partirà quindi dall’analisi del mercato dei beni, presentando la curva IS, per passare successivamente al mercato della moneta e all’analisi della regola di Taylor.</p>
<section id="la-domanda-aggregata" class="level2">
<h2 class="anchored" data-anchor-id="la-domanda-aggregata">La domanda aggregata</h2>
<p>Si è vista nella prima sezione l’identità contabile fondamentale: <span class="math display">\[
    Y=C+I+G+NX
\]</span> dove il termine di sinistra rappresenza l’offerta aggregata, mentre il termine di destra riporta le componenti della domanda aggregata. Piuttosto che ad un concetto contabile, conviene pensare a questa uguaglianza come ad una condizione di equilibrio: perchè il mercato dei beni sia in equilibrio, è necessario che la domanda e l’offerta si incontrino. Nel framework Keynesiano di breve periodo, si può immaginare che l’offerta sia determinata dalla domanda, che a sua volta è determinata da forze esogene.</p>
<p>Si vedrà ora rapidamente quali siano le determinanti della domanda in questo modello semplificato.</p>
<ul>
<li>Il <strong>consumo</strong> delle famiglie <span class="math inline">\(C\)</span> è una funzione della ricchezza <span class="math inline">\(\Omega\)</span> e del reddito ante imposte, dove le imposte <span class="math inline">\(T\)</span> vengono trattate come esogene per semplicità. L’idea qui è semplicemente che maggiori disponibilità economiche producano maggiori consumi. In simboli: <span class="math inline">\(C=\mathcal{C}\left(Y-\bar{T},\Omega\right)\)</span><br>
</li>
<li>L’<strong>investimento</strong> delle imprese dipende dal tasso di interesse reale <span class="math inline">\(r\)</span> e dalla <span class="math inline">\(q\)</span> di Tobin, un parametro che cattura le aspettative degli imprenditori. Chiaramente, quando il costo del capitale è maggiore, gli investimenti diminuiranno, in periodi di tassi bassi questi aumenteranno. In simboli: <span class="math inline">\(I=\mathcal{I}\left(r,q\right)\)</span><br>
</li>
<li>Le <strong>importazioni</strong> dipendono dalla domanda interna <span class="math inline">\(C+I+\bar{G}\)</span> e dal tasso di cambio reale <span class="math inline">\(\epsilon\)</span>. Una spesa interna maggiore comporterà, in media, maggiori import, e un apprezzamento del tasso di cambio reale renderà l’acquisto di beni esteri meno oneroso, incoraggiando le importazioni (e sfavorendo le esportazioni). Si ha quindi <span class="math inline">\(IM=\mathcal{IM}\left(C+I+\bar{G},\epsilon\right)\)</span><br>
</li>
<li>In maniera simile, le <strong>esportazioni</strong> sono funzione della domanda estera (<span class="math inline">\(A^*=C^*+I^*+G^*\)</span>) e del tasso di cambio reale: <span class="math inline">\(EX=\mathcal{EX}\left(A^*,\epsilon\right)\)</span><br>
</li>
<li>Semplificando le due equazioni precedenti, notando che <span class="math inline">\(A \propto Y\)</span> e <span class="math inline">\(\bar{A^*} \propto Y^*\)</span>, si ottiene la funzione per le <strong>esportazioni nette</strong>: <span class="math inline">\(NX=\mathcal{NX}\left(Y,Y^*,\epsilon\right)\)</span>. Come si può immaginare, un maggiore prodotto interno riduce le esportazioni nettem così come un apprezzamento del tasso di cambio reale.</li>
</ul>
<p>Concludendo, si riprende ora l’equazione iniziale, indicando le componenti della domanda: <span class="math display">\[
    Y = ZZ = \mathcal{C}\left(Y-\bar{T},\Omega\right) + \mathcal{I}\left(r,q\right) + \mathcal{NX}\left(Y,Y^*,\epsilon\right)
\]</span> dove il PIL che soddisfa la precedente equazione è detto PIL di equilibrio e <span class="math inline">\(ZZ\)</span> indica la <strong>domanda desiderata</strong>.<br>
Conviene concentrarsi su due aspetti prima di proseguire:</p>
<ol type="1">
<li>C’è una apparente contraddizione nella precedente funzione, in quando <span class="math inline">\(Y\)</span> interviene sia aumentando il consumo che riducendo le esportazioni nette. I dati hanno dimostrato che un incremento <span class="math inline">\(\Delta Y\)</span> produce degli incrementi <span class="math inline">\(|\Delta C| &gt; |\Delta NX|\)</span> quindi <span class="math inline">\(\Delta Y &gt;0 \Rightarrow \Delta ZZ &gt;0\)</span><br>
</li>
<li>Nel breve periodo variazioni delel variabili esogene producono variazioni della domanda tali per cui <span class="math inline">\(ZZ_{t_1}&lt;ZZ_{t_0}\)</span> e <span class="math inline">\(ZZ_{t_1}&lt;Y_{t_1}\)</span>. In questo caso, dal momento che la produzione è maggiore della domanda, le aziende inizieranno ad accumulare merce invenduta come scorte di magazzino, per poi ridurre il livello della produzione fino a che questo non incontrerà la domanda desiderata. Il processo inverso si ottiene quando la domanda desiderata supererà la produzione attuale.</li>
</ol>
</section>
<section id="la-curva-is" class="level2">
<h2 class="anchored" data-anchor-id="la-curva-is">La curva IS</h2>
<p>La curva IS rappresenta le combinazioni del tasso di interesse nominale <span class="math inline">\(i\)</span> (si ricorda che nel breve periodo <span class="math inline">\(\pi \approx 0\)</span> e <span class="math inline">\(r \approx i\)</span>) e del PIL <span class="math inline">\(Y\)</span> che sono coerenti con l’equilibrio nel mercato dei beni.<br>
Nella seguente rappresentazione, è possibile interagire modificando i valori delle variabili esogene. Inoltre, è consentito variare <span class="math inline">\(i\)</span> ma non <span class="math inline">\(Y\)</span>, in quanto variazioni del prodotto porterebbero temporaneamente nelle aree di eccesso di domanda o di offerta, riassorbite nel breve periodo. Inoltre, non è possibile interagire con le determinanti di <span class="math inline">\(\epsilon\)</span> - <span class="math inline">\(P\)</span> e <span class="math inline">\(P^*\)</span>, in quanto ciò contraddirebbe l’ipotesi 1.</p>
<div id="wrapper">
<div id="container1">

</div>
<div id="sliders-container">
<h3 class="slider-title anchored">
Variabili:
</h3>
<p><input type="range" id="delta_y" min="-0.7" max="0.7" step="0.02" value="0" class="slider"> <label for="Δy">Δy</label></p>
<p><input type="range" id="delta_r" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="Δr">Δr</label></p>
<p><input type="range" id="delta_T" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="ΔT">ΔT</label></p>
<p><input type="range" id="delta_G" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="ΔG">ΔG</label></p>
<p><input type="range" id="delta_O" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="ΔΩ">ΔΩ</label></p>
<p><input type="range" id="delta_q" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="Δq">Δq</label></p>
<p><input type="range" id="delta_Ystar" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="ΔY*">ΔY*</label></p>
<p><input type="range" id="delta_e" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="Δε">Δε</label></p>
</div>
</div>
<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 500;
const height = 500;
const marginTop = 0;
const marginRight = 0;
const marginBottom = 0;
const marginLeft = 0;

// Declare the x (horizontal position) scale.
const x = d3.scaleLinear()
    .domain([-1, 1])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([-1, 1])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

svg.append("rect")
  .attr("width", width)
  .attr("height", height)
  .attr("fill", "white");

// Add the x-axis line (without ticks/labels).
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", marginLeft)
    .attr("x2", width - marginRight)
    .attr("y1", 0)
    .attr("y2", 0);

// Add the y-axis line (without ticks/labels).
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", 0)
    .attr("x2", 0)
    .attr("y1", marginTop)
    .attr("y2", height - marginBottom);

// Add the upper-line
svg.append("g")
    .attr("transform", `translate(0,${marginTop})`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", marginLeft)
    .attr("x2", width - marginRight)
    .attr("y1", 0)
    .attr("y2", 0);

// Add the right-line
svg.append("g")
    .attr("transform", `translate(${width-marginLeft},0)`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", 0)
    .attr("x2", 0)
    .attr("y1", marginTop)
    .attr("y2", height - marginBottom);

// Create the line generator.
const line = d3.line()
    .x(d => x(d.x))
    .y(d => y(d.y));

// Generate initial data.

const IS_ = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: -d }));
let IS = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: -d }));
let x_eq = 0
let y_eq = 0


// Append the original reference line.
svg.append("path")
    .datum(IS_)
    .attr("fill", "none")
    .attr("stroke", "#525252")
    .attr("stroke-width", 2)
    .attr("d", line);

// Append the dynamic IS curve.
const ISLine = svg.append("path")
    .datum(IS)
    .attr("fill", "none")
    .attr("stroke", "#04AA6D")
    .attr("stroke-width", 4)
    .attr("d", line);

// Append equilibrium point
let initialX = x(x_eq)
let initialY = y(y_eq)
let initialRadius = 7.5

const dot = svg.append("circle")
    .attr("cx", initialX)
    .attr("cy", initialY)
    .attr("r", initialRadius)
    .attr("fill", "red");

// Append various text
svg.append("text")
  .attr("x", x(0)) 
  .attr("y", y(-.95))
  .attr("text-anchor", "middle")
  .attr("dy", ".35em")
  .style("fill", "#525252")
  .style("font-size", "16px")
  .text("Y");

svg.append("text")
  .attr("x", x(-.95)) 
  .attr("y", y(0))
  .attr("text-anchor", "middle")
  .attr("dy", ".35em")
  .style("fill", "#525252")
  .style("font-size", "16px")
  .text("i");

svg.append("text")
  .attr("x", x(-.5)) 
  .attr("y", y(-.5))
  .attr("text-anchor", "middle")
  .attr("dy", ".35em")
  .style("fill", "silver")
  .style("font-size", "12px")
  .text("ECCESSO DI DOMANDA");

svg.append("text")
  .attr("x", x(.5)) 
  .attr("y", y(.5))
  .attr("text-anchor", "middle")
  .attr("dy", ".35em")
  .style("fill", "silver")
  .style("font-size", "12px")
  .text("ECCESSO DI OFFERTA");

// Function to update the IS curve when sliders change.
function updateLine() {

    let delta_y = parseFloat(document.getElementById("delta_y").value);
    let delta_r = parseFloat(document.getElementById("delta_r").value);
    let delta_T = parseFloat(document.getElementById("delta_T").value);
    let delta_G = parseFloat(document.getElementById("delta_G").value);
    let delta_O = parseFloat(document.getElementById("delta_O").value);
    let delta_q = parseFloat(document.getElementById("delta_q").value);
    let delta_Ystar = parseFloat(document.getElementById("delta_Ystar").value);
    let delta_e = parseFloat(document.getElementById("delta_e").value);
    let exog_values = -delta_T + delta_G + delta_O + delta_q + delta_Ystar - delta_e;

    // Update IS curve data
    IS = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: exog_values - d }));

    // Update the line with new data
    ISLine.datum(IS)
        .attr("d", line);

    // Update equilibrium
    x_eq = - delta_r
    y_eq = exog_values - x_eq

    // Update equilibrium point
    dot.attr("cx", x(x_eq+delta_y))
        .attr("cy", y(y_eq))


}

// Attach event listeners to sliders
document.querySelectorAll("input[type=range]").forEach(slider => {
    slider.addEventListener("input", updateLine);
});

const yslider = d3.select("#delta_y");
yslider.on("change", function() {
    let delta_r = parseFloat(document.getElementById("delta_r").value)
    dot.transition()
        .duration(500)
        .attr("cx", x(- delta_r))
    yslider.property("value", 0);
});

// Append the SVG element.
document.getElementById("container1").appendChild(svg.node());

</script>
</section>
<section id="la-curva-tr" class="level2">
<h2 class="anchored" data-anchor-id="la-curva-tr">La curva TR</h2>
<p>La curva TR (Taylor Rule) individua i livelli di PIL e tasso di interesse che individuano l’equilibrio sul mercato monetario. Si è visto in particolare come la regola di Taylor sia in grado di approssimare fedelmente gli interventi della banca centrale, tramite la seguente equazione: <span class="math display">\[
    i = \bar{i} + \alpha\left(\pi-\bar{\pi}\right) + \beta y
\]</span> dove <span class="math inline">\(\alpha\)</span> e <span class="math inline">\(\beta\)</span> rappresentano l’importanza attribuita dalla banca centrale agli scostamenti dell’inflazione dall’ inflazione target <span class="math inline">\(\bar{\pi}\)</span> e del PIL <span class="math inline">\(Y\)</span> dal suo livello naturale <span class="math inline">\(Y^n\)</span>, relazione catturata dall’output gap <span class="math inline">\(y\)</span>. <span class="math inline">\(\bar{i}\)</span> rappresenta il tasso di interesse naturale che si otterrebbe qualora <span class="math inline">\(y=0\)</span> e <span class="math inline">\(\pi=\bar{\pi}\)</span>.<br>
Importante notare che nel breve periodo, per l’ipotesi iniziale la regola si riduce a: <span class="math display">\[
    i = \bar{i} + \beta y
\]</span> Da questa formula derivano due osservazioni fondamentali:</p>
<ol type="1">
<li>A differenza del mercato dei beni, l’economia non può qui mai trovarsi fuori dalla curva TR. Per definizione, infatti, la banca centrale non sceglierà punti che non siano coerenti con la regola adottata.<br>
</li>
<li>Quando <span class="math inline">\(y=0\)</span>, <span class="math inline">\(i=\bar{i}\)</span> per ovvi motivi.</li>
</ol>
<div id="wrapper">
<div id="container2">

</div>
<div id="sliders-container">
<h3 class="slider-title anchored">
Variabili:
</h3>
<p><input type="range" id="y" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="y">y</label></p>
<p><input type="range" id="delta_beta" min="-1" max="1" step="0.02" value="0" class="slider"> <label for="Δβ">Δβ</label></p>
<p><input type="range" id="delta_ibar" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="Δibar">Δibar</label></p>
</div>
</div>
<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 500;
const height = 500;
const marginTop = 0;
const marginRight = 0;
const marginBottom = 0;
const marginLeft = 0;

// Declare the x (horizontal position) scale.
const x = d3.scaleLinear()
    .domain([-1, 1])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([-1, 1])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

svg.append("rect")
  .attr("width", width)
  .attr("height", height)
  .attr("fill", "white");

// Add the x-axis line (without ticks/labels).
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", marginLeft)
    .attr("x2", width - marginRight)
    .attr("y1", 0)
    .attr("y2", 0);

// Add the y-axis line (without ticks/labels).
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", 0)
    .attr("x2", 0)
    .attr("y1", marginTop)
    .attr("y2", height - marginBottom);

// Add the upper-line
svg.append("g")
    .attr("transform", `translate(0,${marginTop})`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", marginLeft)
    .attr("x2", width - marginRight)
    .attr("y1", 0)
    .attr("y2", 0);

// Add the right-line
svg.append("g")
    .attr("transform", `translate(${width-marginLeft},0)`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", 0)
    .attr("x2", 0)
    .attr("y1", marginTop)
    .attr("y2", height - marginBottom);

// Create the line generator.
const line = d3.line()
    .x(d => x(d.x))
    .y(d => y(d.y));

// Generate initial data.

const TR_ = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: d }));
let TR = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: d }));
let x_eq = 0
let y_eq = 0


// Append the original reference line.
svg.append("path")
    .datum(TR_)
    .attr("fill", "none")
    .attr("stroke", "#525252")
    .attr("stroke-width", 2)
    .attr("d", line);

// Append the dynamic TR curve.
const TRLine = svg.append("path")
    .datum(TR)
    .attr("fill", "none")
    .attr("stroke", "#8A2BE2")
    .attr("stroke-width", 4)
    .attr("d", line);

// Append equilibrium point
let initialX = x(x_eq)
let initialY = y(y_eq)
let initialRadius = 7.5

const dot = svg.append("circle")
    .attr("cx", initialX)
    .attr("cy", initialY)
    .attr("r", initialRadius)
    .attr("fill", "red");

// Append various text
svg.append("text")
  .attr("x", x(0)) 
  .attr("y", y(-.95))
  .attr("text-anchor", "middle")
  .attr("dy", ".35em")
  .style("fill", "#525252")
  .style("font-size", "16px")
  .text("Y");

svg.append("text")
  .attr("x", x(-.95)) 
  .attr("y", y(0))
  .attr("text-anchor", "middle")
  .attr("dy", ".35em")
  .style("fill", "#525252")
  .style("font-size", "16px")
  .text("i");

// Function to update the TR curve when sliders change.
function updateLine() {

    let y_ = parseFloat(document.getElementById("y").value);
    let delta_beta = parseFloat(document.getElementById("delta_beta").value);
    let delta_ibar = parseFloat(document.getElementById("delta_ibar").value);

    // Update TR curve data
    TR = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: delta_ibar + ( 1 + delta_beta ) * d }));

    // Update the line with new data
    TRLine.datum(TR)
        .attr("d", line);

    // Update equilibrium
    x_eq = y_
    y_eq = delta_ibar + ( 1 + delta_beta ) * x_eq

    // Update equilibrium point
    dot.attr("cx", x(x_eq))
       .attr("cy", y(y_eq))


}

// Attach event listeners to sliders
document.querySelectorAll("input[type=range]").forEach(slider => {
    slider.addEventListener("input", updateLine);
});

// Append the SVG element.
document.getElementById("container2").appendChild(svg.node());

</script>
</section>
<section id="il-modello-is-tr" class="level2">
<h2 class="anchored" data-anchor-id="il-modello-is-tr">Il modello IS-TR</h2>
<p>Nel seguente grafico è possibile replicare l’effetto di shock reali e monetari secondo il modello IS-TR. Attenzione però: i risultati sono validi unicamente dal punto di vista qualitativo.</p>
<div id="wrapper">
<div id="container3">

</div>
<div id="sliders-container">
<h3 class="slider-title anchored">
Variabili:
</h3>
<p><input type="range" id="delta_r_IS_TR" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="Δr">Δr</label></p>
<p><input type="range" id="delta_T_IS_TR" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="ΔT">ΔT</label></p>
<p><input type="range" id="delta_G_IS_TR" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="ΔG">ΔG</label></p>
<p><input type="range" id="delta_O_IS_TR" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="ΔΩ">ΔΩ</label></p>
<p><input type="range" id="delta_q_IS_TR" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="Δq">Δq</label></p>
<p><input type="range" id="delta_Ystar_IS_TR" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="ΔY*">ΔY*</label></p>
<p><input type="range" id="delta_e_IS_TR" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="Δε">Δε</label></p>
<p><input type="range" id="delta_beta_IS_TR" min="-1" max="1" step="0.02" value="0" class="slider"> <label for="Δβ">Δβ</label></p>
<p><input type="range" id="delta_ibar_IS_TR" min="-0.5" max="0.5" step="0.02" value="0" class="slider"> <label for="Δibar">Δibar</label></p>
</div>
</div>
<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 500;
const height = 500;
const marginTop = 0;
const marginRight = 0;
const marginBottom = 0;
const marginLeft = 0;

// Declare the x (horizontal position) scale.
const x = d3.scaleLinear()
    .domain([-1, 1])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([-1, 1])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

svg.append("rect")
  .attr("width", width)
  .attr("height", height)
  .attr("fill", "white");

// Add the x-axis line (without ticks/labels).
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", marginLeft)
    .attr("x2", width - marginRight)
    .attr("y1", 0)
    .attr("y2", 0);

// Add the y-axis line (without ticks/labels).
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", 0)
    .attr("x2", 0)
    .attr("y1", marginTop)
    .attr("y2", height - marginBottom);

// Add the upper-line
svg.append("g")
    .attr("transform", `translate(0,${marginTop})`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", marginLeft)
    .attr("x2", width - marginRight)
    .attr("y1", 0)
    .attr("y2", 0);

// Add the right-line
svg.append("g")
    .attr("transform", `translate(${width-marginLeft},0)`)
    .attr("stroke", "silver")
    .attr("stroke-width", 3)
    .append("line")
    .attr("x1", 0)
    .attr("x2", 0)
    .attr("y1", marginTop)
    .attr("y2", height - marginBottom);

// Create the line generator.
const line = d3.line()
    .x(d => x(d.x))
    .y(d => y(d.y));

// Generate initial data.

const IS_ = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: -d }));
let IS = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: -d }));
const TR_ = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: d }));
let TR = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: d }));
let x_eq = 0
let y_eq = 0

// Append the original reference line.
svg.append("path")
    .datum(IS_)
    .attr("fill", "none")
    .attr("stroke", "#525252")
    .attr("stroke-width", 2)
    .attr("d", line);

// Append the dynamic IS curve.
const ISLine = svg.append("path")
    .datum(IS)
    .attr("fill", "none")
    .attr("stroke", "#04AA6D")
    .attr("stroke-width", 4)
    .attr("d", line);

// Append the original reference line.
svg.append("path")
    .datum(TR_)
    .attr("fill", "none")
    .attr("stroke", "#525252")
    .attr("stroke-width", 2)
    .attr("d", line);

// Append the dynamic TR curve.
const TRLine = svg.append("path")
    .datum(TR)
    .attr("fill", "none")
    .attr("stroke", "#8A2BE2")
    .attr("stroke-width", 4)
    .attr("d", line);

// Append equilibrium point
let initialX = x(x_eq)
let initialY = y(y_eq)
let initialRadius = 7.5

const dot = svg.append("circle")
    .attr("cx", initialX)
    .attr("cy", initialY)
    .attr("r", initialRadius)
    .attr("fill", "red");

// Append various text
svg.append("text")
  .attr("x", x(0)) 
  .attr("y", y(-.95))
  .attr("text-anchor", "middle")
  .attr("dy", ".35em")
  .style("fill", "#525252")
  .style("font-size", "16px")
  .text("Y");

svg.append("text")
  .attr("x", x(-.95)) 
  .attr("y", y(0))
  .attr("text-anchor", "middle")
  .attr("dy", ".35em")
  .style("fill", "#525252")
  .style("font-size", "16px")
  .text("i");

// Function to update the curves when sliders change.
function updateLine() {

    let delta_r = parseFloat(document.getElementById("delta_r_IS_TR").value);
    let delta_T = parseFloat(document.getElementById("delta_T_IS_TR").value);
    let delta_G = parseFloat(document.getElementById("delta_G_IS_TR").value);
    let delta_O = parseFloat(document.getElementById("delta_O_IS_TR").value);
    let delta_q = parseFloat(document.getElementById("delta_q_IS_TR").value);
    let delta_Ystar = parseFloat(document.getElementById("delta_Ystar_IS_TR").value);
    let delta_e = parseFloat(document.getElementById("delta_e_IS_TR").value);
    let exog_values = -delta_T + delta_G + delta_O + delta_q + delta_Ystar - delta_e;
    let delta_beta = parseFloat(document.getElementById("delta_beta_IS_TR").value);
    let delta_ibar = parseFloat(document.getElementById("delta_ibar_IS_TR").value);

    // Update IS curve data
    IS = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: exog_values - d }));

    // Update the line with new data
    ISLine.datum(IS)
        .attr("d", line);

    // Update TR curve data
    TR = d3.range(-0.8, 0.8, 0.02).map(d => ({ x: d, y: delta_ibar + ( 1 + delta_beta ) * d }));

    // Update the line with new data
    TRLine.datum(TR)
        .attr("d", line);

    // Update equilibrium
    x_eq = ( exog_values - delta_ibar ) / ( 2 + delta_beta )
    y_eq = ( exog_values + delta_beta * exog_values + delta_ibar ) / ( 2 + delta_beta )

    // Update equilibrium point
    dot.attr("cx", x(x_eq))
        .attr("cy", y(y_eq))

}

// Attach event listeners to sliders
document.querySelectorAll("input[type=range]").forEach(slider => {
    slider.addEventListener("input", updateLine);
});

// Append the SVG element.
document.getElementById("container3").appendChild(svg.node());

</script>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>